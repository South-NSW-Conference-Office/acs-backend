const fs = require('fs');\nconst path = require('path');\n\n// Log levels\nconst LOG_LEVELS = {\n  ERROR: 0,\n  WARN: 1,\n  INFO: 2,\n  VERBOSE: 3,\n  DEBUG: 4\n};\n\nconst LOG_LEVEL_NAMES = {\n  0: 'ERROR',\n  1: 'WARN',\n  2: 'INFO',\n  3: 'VERBOSE',\n  4: 'DEBUG'\n};\n\n// ANSI color codes for console output\nconst COLORS = {\n  ERROR: '\\x1b[31m',   // Red\n  WARN: '\\x1b[33m',    // Yellow\n  INFO: '\\x1b[36m',    // Cyan\n  VERBOSE: '\\x1b[35m', // Magenta\n  DEBUG: '\\x1b[37m',   // White\n  RESET: '\\x1b[0m'     // Reset\n};\n\nclass LoggerService {\n  constructor() {\n    this.logLevel = LOG_LEVELS[process.env.LOG_LEVEL?.toUpperCase()] ?? LOG_LEVELS.INFO;\n    this.logFile = process.env.LOG_FILE || 'logs/app.log';\n    this.enableConsole = process.env.NODE_ENV !== 'production';\n    this.enableFile = true;\n    \n    // Ensure log directory exists\n    this.ensureLogDirectory();\n    \n    // Initialize log rotation\n    this.initLogRotation();\n  }\n\n  ensureLogDirectory() {\n    const logDir = path.dirname(this.logFile);\n    if (!fs.existsSync(logDir)) {\n      fs.mkdirSync(logDir, { recursive: true });\n    }\n  }\n\n  initLogRotation() {\n    // Rotate logs daily\n    setInterval(() => {\n      this.rotateLogFile();\n    }, 24 * 60 * 60 * 1000); // 24 hours\n  }\n\n  rotateLogFile() {\n    try {\n      if (!fs.existsSync(this.logFile)) return;\n\n      const stats = fs.statSync(this.logFile);\n      const fileSize = stats.size;\n      const maxSize = 10 * 1024 * 1024; // 10MB\n\n      if (fileSize > maxSize) {\n        const timestamp = new Date().toISOString().split('T')[0];\n        const rotatedFile = this.logFile.replace('.log', `_${timestamp}.log`);\n        \n        fs.renameSync(this.logFile, rotatedFile);\n        \n        // Compress old log file\n        this.compressLogFile(rotatedFile);\n        \n        // Clean up old log files (keep last 30 days)\n        this.cleanOldLogs();\n      }\n    } catch (error) {\n      console.error('Log rotation failed:', error);\n    }\n  }\n\n  compressLogFile(filePath) {\n    // In a real implementation, you might use gzip compression\n    // For now, we'll just keep the original file\n  }\n\n  cleanOldLogs() {\n    try {\n      const logDir = path.dirname(this.logFile);\n      const files = fs.readdirSync(logDir);\n      const cutoff = new Date();\n      cutoff.setDate(cutoff.getDate() - 30); // 30 days ago\n\n      files.forEach(file => {\n        const filePath = path.join(logDir, file);\n        const stats = fs.statSync(filePath);\n        \n        if (stats.mtime < cutoff && file.endsWith('.log') && file !== path.basename(this.logFile)) {\n          fs.unlinkSync(filePath);\n        }\n      });\n    } catch (error) {\n      console.error('Log cleanup failed:', error);\n    }\n  }\n\n  formatMessage(level, message, metadata = {}) {\n    const timestamp = new Date().toISOString();\n    const levelName = LOG_LEVEL_NAMES[level];\n    \n    const logEntry = {\n      timestamp,\n      level: levelName,\n      message,\n      ...metadata\n    };\n\n    return {\n      json: JSON.stringify(logEntry),\n      console: `${timestamp} [${levelName}] ${message}${metadata && Object.keys(metadata).length > 0 ? ` ${JSON.stringify(metadata)}` : ''}`\n    };\n  }\n\n  writeToFile(formattedMessage) {\n    if (!this.enableFile) return;\n\n    try {\n      fs.appendFileSync(this.logFile, formattedMessage.json + '\\n');\n    } catch (error) {\n      console.error('Failed to write to log file:', error);\n    }\n  }\n\n  writeToConsole(level, formattedMessage) {\n    if (!this.enableConsole) return;\n\n    const levelName = LOG_LEVEL_NAMES[level];\n    const color = COLORS[levelName] || COLORS.RESET;\n    const coloredMessage = `${color}${formattedMessage.console}${COLORS.RESET}`;\n\n    switch (level) {\n      case LOG_LEVELS.ERROR:\n        console.error(coloredMessage);\n        break;\n      case LOG_LEVELS.WARN:\n        console.warn(coloredMessage);\n        break;\n      default:\n        console.log(coloredMessage);\n    }\n  }\n\n  log(level, message, metadata = {}) {\n    if (level > this.logLevel) return;\n\n    const formattedMessage = this.formatMessage(level, message, metadata);\n    \n    this.writeToFile(formattedMessage);\n    this.writeToConsole(level, formattedMessage);\n  }\n\n  // Public logging methods\n  error(message, metadata = {}) {\n    this.log(LOG_LEVELS.ERROR, message, metadata);\n  }\n\n  warn(message, metadata = {}) {\n    this.log(LOG_LEVELS.WARN, message, metadata);\n  }\n\n  info(message, metadata = {}) {\n    this.log(LOG_LEVELS.INFO, message, metadata);\n  }\n\n  verbose(message, metadata = {}) {\n    this.log(LOG_LEVELS.VERBOSE, message, metadata);\n  }\n\n  debug(message, metadata = {}) {\n    this.log(LOG_LEVELS.DEBUG, message, metadata);\n  }\n\n  // Security logging\n  security(event, metadata = {}) {\n    this.log(LOG_LEVELS.WARN, `SECURITY: ${event}`, {\n      type: 'security',\n      event,\n      timestamp: new Date().toISOString(),\n      ...metadata\n    });\n  }\n\n  // Audit logging\n  audit(action, metadata = {}) {\n    this.log(LOG_LEVELS.INFO, `AUDIT: ${action}`, {\n      type: 'audit',\n      action,\n      timestamp: new Date().toISOString(),\n      ...metadata\n    });\n  }\n\n  // Performance logging\n  performance(operation, duration, metadata = {}) {\n    this.log(LOG_LEVELS.VERBOSE, `PERFORMANCE: ${operation} took ${duration}ms`, {\n      type: 'performance',\n      operation,\n      duration,\n      timestamp: new Date().toISOString(),\n      ...metadata\n    });\n  }\n\n  // Database operation logging\n  database(operation, collection, metadata = {}) {\n    this.log(LOG_LEVELS.DEBUG, `DB: ${operation} on ${collection}`, {\n      type: 'database',\n      operation,\n      collection,\n      timestamp: new Date().toISOString(),\n      ...metadata\n    });\n  }\n\n  // API request logging\n  request(req, res, duration) {\n    const metadata = {\n      type: 'request',\n      method: req.method,\n      url: req.originalUrl,\n      status: res.statusCode,\n      duration,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      userId: req.user?._id,\n      organizationId: req.headers['x-organization-id'],\n      timestamp: new Date().toISOString()\n    };\n\n    const level = res.statusCode >= 400 ? LOG_LEVELS.WARN : LOG_LEVELS.INFO;\n    this.log(level, `${req.method} ${req.originalUrl} ${res.statusCode} ${duration}ms`, metadata);\n  }\n\n  // Express middleware for request logging\n  requestMiddleware() {\n    return (req, res, next) => {\n      const start = Date.now();\n      \n      // Override res.end to capture response\n      const originalEnd = res.end;\n      res.end = function(...args) {\n        const duration = Date.now() - start;\n        logger.request(req, res, duration);\n        originalEnd.apply(this, args);\n      };\n      \n      next();\n    };\n  }\n\n  // Structured query logging\n  query(query, params, duration, metadata = {}) {\n    this.log(LOG_LEVELS.DEBUG, `QUERY: ${query}`, {\n      type: 'query',\n      query,\n      params,\n      duration,\n      timestamp: new Date().toISOString(),\n      ...metadata\n    });\n  }\n}\n\n// Create singleton instance\nconst logger = new LoggerService();\n\n// Export both class and instance\nmodule.exports = logger;\nmodule.exports.LoggerService = LoggerService;\nmodule.exports.LOG_LEVELS = LOG_LEVELS;